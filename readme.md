# Задача 1. Работа с файлом №2
### Что нужно сделать

Реализуйте модернизированную версию контекст-менеджера File: 

* теперь при попытке открыть несуществующий файл менеджер должен автоматически создавать и открывать этот файл в режиме записи; 
* на выходе из менеджера должны подавляться все исключения, связанные с файлами.

### Что оценивается

* Результат вычислений корректен.
* Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
* При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
* Для получения и установки значений приватных атрибутов используются сеттеры и геттеры с соответствующими декораторами.
* Для создания нового класса на основе уже существующего используется наследование.
* Для статических и классовых методов используется декоратор classmethod.
* Сообщения о процессе получения результата осмысленны и понятны для пользователя.
* Переменные, функции и собственные методы классов имеют значащие имена (не a, b, c, d).
* Классы и методы/функции имеют прописанную документацию.
* Есть аннотация типов для методов/функций и их аргументов (кроме args и kwargs). Если функция/метод ничего не возвращает, то используется None.
### Запуск скрипта 
Запуск скрипта осуществляется через файл [main.py](main.py)
*****

# Задача 2. Математический модуль
### Что нужно сделать

Вася использует в своей программе очень много различных математических вычислений, связанных с фигурами. Например, нахождение их площадей или периметров. Поэтому, чтобы не захламлять код огромным количеством функций, он решил выделить для них отдельный класс, подключить как модуль и использовать по аналогии с модулем math.

Реализуйте класс MyMath, состоящий как минимум из следующих методов (можете бонусом добавить и другие методы):

* вычисление длины окружности,
* вычисление площади окружности,
* вычисление объёма куба,
* вычисление площади поверхности сферы.

Пример основного кода:
```python
res_1 = MyMath.circle_len(radius=5)
res_2 = MyMath.circle_sq(radius=6)
print(res_1)
print(res_2)
```
```markdown
Результат:

31.41592653589793

113.09733552923255
```

### Что оценивается

* Результат вычислений корректен.
* Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
* При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
* Для получения и установки значений приватных атрибутов используются сеттеры и геттеры с соответствующими декораторами.
* Для создания нового класса на основе уже существующего используется наследование.
* Для статических и классовых методов используется декоратор classmethod.
* Формат вывода соответствует примеру.
* Переменные, функции и собственные методы классов имеют значащие имена (не a, b, c, d).
* Классы и методы/функции имеют прописанную документацию.
* Есть аннотация типов для методов/функций и их аргументов (кроме args и kwargs). Если функция/метод ничего не возвращает, то используется None.
### Запуск скрипта 
Запуск скрипта осуществляется через файл [main.py](main.py)

*****

# Задача 3. Дата
### Что нужно сделать

Реализуйте класс Date, который должен:

* проверять числа даты на корректность;
* конвертировать строку даты в объект класса Date, состоящий из соответствующих числовых значений дня, месяца и года.

Оба метода должны получать на вход строку вида ‘dd-mm-yyyy’.

При тестировании программы объект класса Date должен инициализироваться исключительно через метод конвертации, например:
```markdown
date = Date.from_string('10-12-2077')

Неверный вариант: date = Date(10, 12, 2077)
```


Пример основного кода:
```python
date = Date.from_string('10-12-2077')
print(date)
print(Date.is_date_valid('10-12-2077'))
print(Date.is_date_valid('40-12-2077'))
```

```markdown
Результат:
День: 10    Месяц: 12    Год: 2077
True
```

### Что оценивается

* Результат вычислений корректен.
* Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
* При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
* Для получения и установки значений приватных атрибутов используются сеттеры и геттеры с соответствующими декораторами.
* Для создания нового класса на основе уже существующего используется наследование.
* Для статических и классовых методов используется декоратор classmethod.
* Формат вывода соответствует примеру.
* Переменные, функции и собственные методы классов имеют значащие имена (не a, b, c, d).
* Классы и методы/функции имеют прописанную документацию.
* Есть аннотация типов для методов/функций и их аргументов (кроме args и kwargs). Если функция/метод ничего не возвращает, то используется None.

### Запуск скрипта 
Запуск скрипта осуществляется через файл [main.py](main.py)

*****
